<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Framework 1: ML System Architecture | Chenhao Zhou</title>
    <meta name="description" content="Designing scalable machine learning systems - architectural patterns, component design, and system integration strategies.">
    <style>
        :root {
            --primary: #0ea5e9;
            --primary-dark: #0284c7;
            --primary-gradient: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%);
            --text-primary: #1a1a1a;
            --text-secondary: #4a4a4a;
            --text-muted: #6b7280;
            --background: #ffffff;
            --surface: #f8fafc;
            --border: #e5e7eb;
            --code-bg: #1e293b;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.7;
        }

        /* Hero */
        .hero {
            background: var(--primary-gradient);
            padding: 60px 20px 80px;
            color: white;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .breadcrumb {
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .breadcrumb a {
            color: white;
            text-decoration: none;
        }

        .breadcrumb a:hover { text-decoration: underline; }

        .hero h1 {
            font-size: clamp(2rem, 4vw, 3rem);
            margin-bottom: 16px;
        }

        .hero-meta {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
            opacity: 0.9;
        }

        /* Navigation */
        .nav-wrapper {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
        }

        .nav-bar {
            max-width: 1000px;
            margin: 0 auto;
            padding: 12px 20px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .nav-link:hover {
            background: var(--primary);
            color: white;
        }

        /* Content */
        .content {
            padding: 48px 20px;
        }

        .section {
            margin-bottom: 64px;
        }

        .section-number {
            display: inline-block;
            background: var(--primary-gradient);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            text-align: center;
            line-height: 36px;
            font-weight: 700;
            margin-right: 12px;
        }

        h2 {
            font-size: 1.75rem;
            margin-bottom: 24px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
        }

        h3 {
            font-size: 1.25rem;
            margin: 32px 0 16px;
            color: var(--primary-dark);
        }

        h4 {
            font-size: 1.1rem;
            margin: 24px 0 12px;
            color: var(--text-primary);
        }

        p {
            margin-bottom: 16px;
            color: var(--text-secondary);
        }

        /* Concept Box */
        .concept-box {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-left: 4px solid var(--primary);
            padding: 24px;
            border-radius: 0 12px 12px 0;
            margin: 24px 0;
        }

        .concept-box h4 {
            color: var(--primary-dark);
            margin-top: 0;
        }

        /* Code Block */
        .code-block {
            background: var(--code-bg);
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            overflow-x: auto;
        }

        .code-block pre {
            color: #e2e8f0;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            margin: 0;
        }

        .code-label {
            color: #94a3b8;
            font-size: 0.8rem;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Diagram */
        .diagram {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 32px;
            margin: 24px 0;
            text-align: center;
        }

        .diagram-title {
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .architecture-flow {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 16px;
        }

        .arch-component {
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 16px 24px;
            font-weight: 600;
            color: var(--primary-dark);
        }

        .arch-arrow {
            color: var(--primary);
            font-size: 1.5rem;
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 24px 0;
            font-size: 0.95rem;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 16px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .comparison-table th {
            background: var(--surface);
            font-weight: 600;
            color: var(--text-primary);
        }

        .comparison-table tr:hover {
            background: #f8fafc;
        }

        /* Feature List */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 24px 0;
        }

        .feature-card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            transition: all 0.2s;
        }

        .feature-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            transform: translateY(-2px);
        }

        .feature-icon {
            font-size: 2rem;
            margin-bottom: 12px;
        }

        .feature-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .feature-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Key Points */
        .key-points {
            background: #fef3c7;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
        }

        .key-points h4 {
            color: #92400e;
            margin-top: 0;
        }

        .key-points ul {
            margin: 0;
            padding-left: 20px;
        }

        .key-points li {
            margin-bottom: 8px;
            color: #78350f;
        }

        /* Practice Exercise */
        .exercise {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            border-radius: 12px;
            padding: 24px;
            margin: 32px 0;
        }

        .exercise h4 {
            color: #065f46;
            margin-top: 0;
        }

        .exercise p, .exercise li {
            color: #047857;
        }

        /* Footer */
        .footer {
            background: var(--text-primary);
            color: white;
            padding: 32px 20px;
            text-align: center;
        }

        .footer a {
            color: rgba(255,255,255,0.8);
            text-decoration: none;
            margin: 0 16px;
        }

        .footer a:hover { color: white; }

        @media (max-width: 768px) {
            .architecture-flow { flex-direction: column; }
            .arch-arrow { transform: rotate(90deg); }
        }
    </style>
</head>
<body>
    <!-- Hero -->
    <section class="hero">
        <div class="container">
            <div class="breadcrumb">
                <a href="index.html">ML Frameworks Course</a> / Framework 1
            </div>
            <h1>ML System Architecture</h1>
            <div class="hero-meta">
                <span>Framework 1 of 4</span>
                <span>|</span>
                <span>Estimated: 4-6 hours</span>
                <span>|</span>
                <span>Level: Intermediate to Advanced</span>
            </div>
        </div>
    </section>

    <!-- Navigation -->
    <div class="nav-wrapper">
        <nav class="nav-bar">
            <a href="#introduction" class="nav-link">Introduction</a>
            <a href="#patterns" class="nav-link">Architecture Patterns</a>
            <a href="#components" class="nav-link">Core Components</a>
            <a href="#feature-stores" class="nav-link">Feature Stores</a>
            <a href="#model-registry" class="nav-link">Model Registry</a>
            <a href="#api-design" class="nav-link">API Design</a>
            <a href="index.html" class="nav-link">Back to Course</a>
        </nav>
    </div>

    <!-- Content -->
    <main class="content">
        <div class="container">

            <!-- Section 1: Introduction -->
            <section id="introduction" class="section">
                <h2><span class="section-number">1</span>Introduction to ML System Design</h2>

                <p>Building production machine learning systems requires thinking beyond model accuracy. A well-architected ML system must handle data flow, model serving, monitoring, and iteration at scale. This framework teaches you to design systems that are maintainable, scalable, and reliable.</p>

                <div class="concept-box">
                    <h4>Why Architecture Matters in ML</h4>
                    <p>Unlike traditional software, ML systems have unique challenges:</p>
                    <ul>
                        <li><strong>Data dependencies:</strong> Models depend on data quality, freshness, and consistency</li>
                        <li><strong>Experiment tracking:</strong> Need to reproduce and compare model versions</li>
                        <li><strong>Training-serving skew:</strong> Features must behave identically in training and inference</li>
                        <li><strong>Model decay:</strong> Performance degrades as data distributions shift over time</li>
                    </ul>
                </div>

                <h3>The ML System Lifecycle</h3>

                <div class="diagram">
                    <div class="diagram-title">End-to-End ML System Flow</div>
                    <div class="architecture-flow">
                        <div class="arch-component">Data Sources</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Feature Store</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Training Pipeline</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Model Registry</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Serving Layer</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Monitoring</div>
                    </div>
                </div>

                <p>Each component in this pipeline serves a specific purpose and must integrate seamlessly with others. Poor architecture decisions early on create technical debt that becomes increasingly expensive to address.</p>
            </section>

            <!-- Section 2: Architecture Patterns -->
            <section id="patterns" class="section">
                <h2><span class="section-number">2</span>ML Architecture Patterns</h2>

                <p>Choosing the right architecture pattern depends on your organization's scale, team structure, and use case requirements. Here we examine the three primary patterns used in production ML systems.</p>

                <h3>2.1 Monolithic Architecture</h3>

                <p>In a monolithic ML architecture, all components—data processing, training, and serving—exist within a single application or codebase.</p>

                <div class="code-block">
                    <div class="code-label">Monolithic ML Service Structure</div>
                    <pre>
ml_service/
├── data/
│   ├── ingestion.py        # Data collection
│   ├── preprocessing.py    # Feature engineering
│   └── validation.py       # Data quality checks
├── models/
│   ├── train.py           # Training logic
│   ├── evaluate.py        # Model evaluation
│   └── artifacts/         # Saved models
├── serving/
│   ├── api.py             # REST endpoints
│   ├── predictor.py       # Inference logic
│   └── batch.py           # Batch predictions
└── app.py                 # Main application</pre>
                </div>

                <div class="key-points">
                    <h4>When to Use Monolithic Architecture</h4>
                    <ul>
                        <li>Small teams (1-5 ML engineers)</li>
                        <li>Single model or few closely related models</li>
                        <li>Rapid prototyping and MVP development</li>
                        <li>Limited infrastructure resources</li>
                    </ul>
                </div>

                <h3>2.2 Microservices Architecture</h3>

                <p>Microservices decompose the ML system into independent, loosely-coupled services that communicate via APIs. Each service owns its data, logic, and deployment lifecycle.</p>

                <div class="diagram">
                    <div class="diagram-title">Microservices ML Architecture</div>
                    <div class="architecture-flow">
                        <div class="arch-component">API Gateway</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Feature Service</div>
                    </div>
                    <div class="architecture-flow" style="margin-top: 16px;">
                        <div class="arch-component">API Gateway</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Prediction Service</div>
                    </div>
                    <div class="architecture-flow" style="margin-top: 16px;">
                        <div class="arch-component">API Gateway</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Training Service</div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-label">Python - Microservice Prediction Endpoint</div>
                    <pre>
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import httpx

app = FastAPI()

class PredictionRequest(BaseModel):
    user_id: str
    context: dict

class PredictionResponse(BaseModel):
    prediction: float
    confidence: float
    model_version: str

@app.post("/predict", response_model=PredictionResponse)
async def predict(request: PredictionRequest):
    # Fetch features from Feature Service
    async with httpx.AsyncClient() as client:
        feature_response = await client.get(
            f"http://feature-service/features/{request.user_id}"
        )
        features = feature_response.json()

    # Load model and make prediction
    model = model_registry.get_latest("recommendation_model")
    prediction = model.predict(features)

    return PredictionResponse(
        prediction=prediction.value,
        confidence=prediction.confidence,
        model_version=model.version
    )</pre>
                </div>

                <h3>2.3 Architecture Comparison</h3>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Monolithic</th>
                            <th>Microservices</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Deployment</td>
                            <td>Single deployment unit</td>
                            <td>Independent service deployments</td>
                        </tr>
                        <tr>
                            <td>Scaling</td>
                            <td>Scale entire application</td>
                            <td>Scale individual services</td>
                        </tr>
                        <tr>
                            <td>Team Structure</td>
                            <td>Shared codebase</td>
                            <td>Service ownership per team</td>
                        </tr>
                        <tr>
                            <td>Complexity</td>
                            <td>Lower initial complexity</td>
                            <td>Higher operational overhead</td>
                        </tr>
                        <tr>
                            <td>Fault Isolation</td>
                            <td>Failure affects entire system</td>
                            <td>Failures contained to service</td>
                        </tr>
                        <tr>
                            <td>Technology Choice</td>
                            <td>Single technology stack</td>
                            <td>Polyglot (multiple languages/frameworks)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>2.4 Hybrid Approach: Modular Monolith</h3>

                <p>Many teams find success with a modular monolith—a single deployable unit with clear internal boundaries. This provides the simplicity of monolithic deployment with the organizational benefits of service-oriented design.</p>

                <div class="code-block">
                    <div class="code-label">Modular Monolith Structure</div>
                    <pre>
ml_platform/
├── core/
│   ├── __init__.py
│   └── config.py
├── features/              # Feature engineering module
│   ├── __init__.py
│   ├── store.py
│   ├── transformers.py
│   └── api.py
├── training/              # Training module
│   ├── __init__.py
│   ├── pipelines.py
│   ├── experiments.py
│   └── api.py
├── serving/               # Serving module
│   ├── __init__.py
│   ├── predictors.py
│   ├── batch.py
│   └── api.py
├── monitoring/            # Monitoring module
│   ├── __init__.py
│   ├── metrics.py
│   └── alerts.py
└── main.py               # Unified entry point</pre>
                </div>
            </section>

            <!-- Section 3: Core Components -->
            <section id="components" class="section">
                <h2><span class="section-number">3</span>Core System Components</h2>

                <p>Every production ML system requires certain foundational components. Understanding their responsibilities and interactions is essential for effective system design.</p>

                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-icon">Data Layer</div>
                        <div class="feature-title">Data Layer</div>
                        <div class="feature-desc">Manages data ingestion, storage, and retrieval. Includes data lakes, warehouses, and streaming pipelines.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">Features</div>
                        <div class="feature-title">Feature Store</div>
                        <div class="feature-desc">Centralized repository for feature definitions, computation, and serving with consistency guarantees.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">Training</div>
                        <div class="feature-title">Training Infrastructure</div>
                        <div class="feature-desc">Orchestrates model training jobs, manages compute resources, and tracks experiments.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">Registry</div>
                        <div class="feature-title">Model Registry</div>
                        <div class="feature-desc">Version control for models with metadata, lineage tracking, and deployment state management.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">Serving</div>
                        <div class="feature-title">Serving Layer</div>
                        <div class="feature-desc">Handles real-time and batch predictions with load balancing, caching, and fallback logic.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">Monitor</div>
                        <div class="feature-title">Monitoring</div>
                        <div class="feature-desc">Tracks model performance, data drift, system health, and triggers alerts for anomalies.</div>
                    </div>
                </div>

                <h3>Component Integration Patterns</h3>

                <div class="code-block">
                    <div class="code-label">Python - Component Integration Example</div>
                    <pre>
from dataclasses import dataclass
from typing import Dict, Any, Optional
from abc import ABC, abstractmethod

# Abstract interfaces for loose coupling
class FeatureStore(ABC):
    @abstractmethod
    def get_features(self, entity_id: str, feature_names: list) -> Dict[str, Any]:
        pass

class ModelRegistry(ABC):
    @abstractmethod
    def get_model(self, name: str, version: Optional[str] = None):
        pass

class MetricsCollector(ABC):
    @abstractmethod
    def record_prediction(self, model_name: str, latency: float, features: dict):
        pass

# Prediction service using dependency injection
@dataclass
class PredictionService:
    feature_store: FeatureStore
    model_registry: ModelRegistry
    metrics: MetricsCollector

    def predict(self, entity_id: str, model_name: str) -> dict:
        import time
        start = time.time()

        # Get features
        features = self.feature_store.get_features(
            entity_id,
            feature_names=["feature_a", "feature_b", "feature_c"]
        )

        # Get model
        model = self.model_registry.get_model(model_name)

        # Make prediction
        prediction = model.predict(features)

        # Record metrics
        latency = time.time() - start
        self.metrics.record_prediction(model_name, latency, features)

        return {
            "prediction": prediction,
            "model_version": model.version,
            "latency_ms": latency * 1000
        }</pre>
                </div>
            </section>

            <!-- Section 4: Feature Stores -->
            <section id="feature-stores" class="section">
                <h2><span class="section-number">4</span>Feature Stores</h2>

                <p>A feature store is a centralized system for storing, managing, and serving features for machine learning. It solves the critical problem of training-serving skew and enables feature reuse across teams.</p>

                <div class="concept-box">
                    <h4>The Feature Store Problem</h4>
                    <p>Without a feature store, organizations face:</p>
                    <ul>
                        <li><strong>Duplicate work:</strong> Teams rebuild the same features independently</li>
                        <li><strong>Training-serving skew:</strong> Features computed differently in training vs. production</li>
                        <li><strong>Data freshness issues:</strong> Batch features may be stale for real-time serving</li>
                        <li><strong>No feature discovery:</strong> Teams unaware of existing features they could reuse</li>
                    </ul>
                </div>

                <h3>4.1 Feature Store Architecture</h3>

                <div class="diagram">
                    <div class="diagram-title">Dual-Store Architecture (Offline + Online)</div>
                    <div class="architecture-flow">
                        <div class="arch-component">Feature Pipelines</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Offline Store (Historical)</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Training Jobs</div>
                    </div>
                    <div class="architecture-flow" style="margin-top: 16px;">
                        <div class="arch-component">Feature Pipelines</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Online Store (Low Latency)</div>
                        <span class="arch-arrow">→</span>
                        <div class="arch-component">Prediction Service</div>
                    </div>
                </div>

                <h3>4.2 Implementing Feature Definitions</h3>

                <div class="code-block">
                    <div class="code-label">Python - Feature Definition with Feast</div>
                    <pre>
from feast import Entity, Feature, FeatureView, FileSource, ValueType
from datetime import timedelta

# Define the entity (what we're making predictions about)
customer = Entity(
    name="customer_id",
    value_type=ValueType.INT64,
    description="Unique customer identifier"
)

# Define the data source
customer_transactions_source = FileSource(
    path="data/customer_transactions.parquet",
    event_timestamp_column="event_timestamp",
    created_timestamp_column="created_timestamp"
)

# Define the feature view
customer_transaction_features = FeatureView(
    name="customer_transactions",
    entities=["customer_id"],
    ttl=timedelta(days=90),
    features=[
        Feature(name="transaction_count_30d", dtype=ValueType.INT64),
        Feature(name="avg_transaction_amount_30d", dtype=ValueType.FLOAT),
        Feature(name="days_since_last_transaction", dtype=ValueType.INT64),
        Feature(name="total_lifetime_value", dtype=ValueType.FLOAT),
    ],
    online=True,
    batch_source=customer_transactions_source,
)</pre>
                </div>

                <h3>4.3 Feature Retrieval for Training</h3>

                <div class="code-block">
                    <div class="code-label">Python - Point-in-Time Feature Retrieval</div>
                    <pre>
from feast import FeatureStore
import pandas as pd

store = FeatureStore(repo_path=".")

# Training data with timestamps (point-in-time correct)
training_df = pd.DataFrame({
    "customer_id": [1001, 1002, 1003, 1001, 1002],
    "event_timestamp": pd.to_datetime([
        "2024-01-15", "2024-01-16", "2024-01-17",
        "2024-02-01", "2024-02-01"
    ]),
    "label": [1, 0, 1, 0, 1]
})

# Get historical features (point-in-time join)
training_data = store.get_historical_features(
    entity_df=training_df,
    features=[
        "customer_transactions:transaction_count_30d",
        "customer_transactions:avg_transaction_amount_30d",
        "customer_transactions:days_since_last_transaction",
        "customer_transactions:total_lifetime_value",
    ]
).to_df()

print(training_data.head())</pre>
                </div>

                <h3>4.4 Feature Retrieval for Serving</h3>

                <div class="code-block">
                    <div class="code-label">Python - Online Feature Retrieval</div>
                    <pre>
from feast import FeatureStore

store = FeatureStore(repo_path=".")

# Real-time feature retrieval for prediction
def get_prediction_features(customer_ids: list) -> dict:
    """Get features for real-time prediction."""

    online_features = store.get_online_features(
        features=[
            "customer_transactions:transaction_count_30d",
            "customer_transactions:avg_transaction_amount_30d",
            "customer_transactions:days_since_last_transaction",
            "customer_transactions:total_lifetime_value",
        ],
        entity_rows=[{"customer_id": cid} for cid in customer_ids]
    ).to_dict()

    return online_features

# Usage in prediction service
features = get_prediction_features([1001, 1002])
predictions = model.predict(features)</pre>
                </div>

                <div class="exercise">
                    <h4>Practice Exercise: Feature Store Design</h4>
                    <p>Design a feature store schema for an e-commerce recommendation system. Consider:</p>
                    <ul>
                        <li>What entities do you need? (users, products, sessions?)</li>
                        <li>What features would be computed in batch vs. real-time?</li>
                        <li>How would you handle feature freshness requirements?</li>
                        <li>What's your strategy for feature versioning?</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Model Registry -->
            <section id="model-registry" class="section">
                <h2><span class="section-number">5</span>Model Registry & Versioning</h2>

                <p>A model registry provides version control for machine learning models, tracking artifacts, metadata, and deployment state. It's essential for reproducibility, governance, and production reliability.</p>

                <h3>5.1 Model Registry Functions</h3>

                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-title">Version Control</div>
                        <div class="feature-desc">Track model versions with immutable artifacts and metadata snapshots.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-title">Lineage Tracking</div>
                        <div class="feature-desc">Record which data and code produced each model version.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-title">Stage Management</div>
                        <div class="feature-desc">Track models through staging, production, and archived states.</div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-title">Access Control</div>
                        <div class="feature-desc">Manage who can register, approve, and deploy models.</div>
                    </div>
                </div>

                <h3>5.2 Using MLflow Model Registry</h3>

                <div class="code-block">
                    <div class="code-label">Python - Registering a Model</div>
                    <pre>
import mlflow
from mlflow.tracking import MlflowClient

# Set tracking URI
mlflow.set_tracking_uri("http://mlflow-server:5000")
mlflow.set_experiment("customer_churn_prediction")

# Train and log model
with mlflow.start_run() as run:
    # Log parameters
    mlflow.log_params({
        "model_type": "xgboost",
        "max_depth": 6,
        "learning_rate": 0.1,
        "n_estimators": 100
    })

    # Train model
    model = train_model(X_train, y_train)

    # Log metrics
    mlflow.log_metrics({
        "auc_roc": 0.87,
        "precision": 0.82,
        "recall": 0.79,
        "f1_score": 0.80
    })

    # Log model with signature
    from mlflow.models.signature import infer_signature
    signature = infer_signature(X_train, model.predict(X_train))

    mlflow.xgboost.log_model(
        model,
        "model",
        signature=signature,
        registered_model_name="customer_churn_model"
    )</pre>
                </div>

                <h3>5.3 Model Staging Workflow</h3>

                <div class="code-block">
                    <div class="code-label">Python - Managing Model Stages</div>
                    <pre>
from mlflow.tracking import MlflowClient

client = MlflowClient()

# Get latest version
latest_versions = client.get_latest_versions(
    name="customer_churn_model",
    stages=["None", "Staging", "Production"]
)

# Transition model to staging
client.transition_model_version_stage(
    name="customer_churn_model",
    version=3,
    stage="Staging",
    archive_existing_versions=False
)

# After validation, promote to production
client.transition_model_version_stage(
    name="customer_churn_model",
    version=3,
    stage="Production",
    archive_existing_versions=True  # Archive previous production version
)

# Load production model for serving
import mlflow.pyfunc

model = mlflow.pyfunc.load_model(
    model_uri="models:/customer_churn_model/Production"
)

predictions = model.predict(new_data)</pre>
                </div>

                <div class="concept-box">
                    <h4>Model Metadata Best Practices</h4>
                    <p>Every registered model should include:</p>
                    <ul>
                        <li><strong>Training data reference:</strong> Version or snapshot ID of training data</li>
                        <li><strong>Feature schema:</strong> Expected input features and types</li>
                        <li><strong>Performance metrics:</strong> Evaluation metrics on holdout data</li>
                        <li><strong>Code commit:</strong> Git SHA of training code</li>
                        <li><strong>Dependencies:</strong> Package versions used for training</li>
                        <li><strong>Owner:</strong> Team or individual responsible</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: API Design -->
            <section id="api-design" class="section">
                <h2><span class="section-number">6</span>API Design for ML Services</h2>

                <p>Well-designed APIs make ML systems accessible, reliable, and maintainable. This section covers best practices for designing prediction APIs.</p>

                <h3>6.1 RESTful Prediction API</h3>

                <div class="code-block">
                    <div class="code-label">Python - FastAPI Prediction Service</div>
                    <pre>
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel, Field
from typing import List, Optional
import mlflow.pyfunc

app = FastAPI(
    title="Churn Prediction API",
    description="Real-time customer churn predictions",
    version="1.0.0"
)

# Request/Response schemas
class CustomerFeatures(BaseModel):
    customer_id: str = Field(..., description="Unique customer identifier")
    transaction_count_30d: int = Field(..., ge=0)
    avg_transaction_amount_30d: float = Field(..., ge=0)
    days_since_last_transaction: int = Field(..., ge=0)
    total_lifetime_value: float = Field(..., ge=0)

    class Config:
        schema_extra = {
            "example": {
                "customer_id": "CUST_12345",
                "transaction_count_30d": 5,
                "avg_transaction_amount_30d": 75.50,
                "days_since_last_transaction": 3,
                "total_lifetime_value": 1250.00
            }
        }

class PredictionResponse(BaseModel):
    customer_id: str
    churn_probability: float = Field(..., ge=0, le=1)
    churn_risk: str  # "low", "medium", "high"
    model_version: str
    prediction_id: str

class BatchPredictionRequest(BaseModel):
    customers: List[CustomerFeatures]

class BatchPredictionResponse(BaseModel):
    predictions: List[PredictionResponse]
    batch_id: str
    processing_time_ms: float

# Model loading
def get_model():
    return mlflow.pyfunc.load_model("models:/customer_churn_model/Production")

# Endpoints
@app.post("/predict", response_model=PredictionResponse)
async def predict_single(
    features: CustomerFeatures,
    model = Depends(get_model)
):
    """Get churn prediction for a single customer."""
    import uuid
    import pandas as pd

    # Prepare features
    df = pd.DataFrame([features.dict(exclude={"customer_id"})])

    # Get prediction
    probability = model.predict(df)[0]

    # Determine risk category
    risk = "low" if probability < 0.3 else "medium" if probability < 0.7 else "high"

    return PredictionResponse(
        customer_id=features.customer_id,
        churn_probability=round(probability, 4),
        churn_risk=risk,
        model_version="3",
        prediction_id=str(uuid.uuid4())
    )

@app.post("/predict/batch", response_model=BatchPredictionResponse)
async def predict_batch(
    request: BatchPredictionRequest,
    model = Depends(get_model)
):
    """Get churn predictions for multiple customers."""
    import uuid
    import time
    import pandas as pd

    start_time = time.time()

    # Prepare batch features
    feature_dicts = [c.dict(exclude={"customer_id"}) for c in request.customers]
    df = pd.DataFrame(feature_dicts)

    # Batch prediction
    probabilities = model.predict(df)

    # Build responses
    predictions = []
    for customer, prob in zip(request.customers, probabilities):
        risk = "low" if prob < 0.3 else "medium" if prob < 0.7 else "high"
        predictions.append(PredictionResponse(
            customer_id=customer.customer_id,
            churn_probability=round(prob, 4),
            churn_risk=risk,
            model_version="3",
            prediction_id=str(uuid.uuid4())
        ))

    return BatchPredictionResponse(
        predictions=predictions,
        batch_id=str(uuid.uuid4()),
        processing_time_ms=(time.time() - start_time) * 1000
    )

@app.get("/health")
async def health_check():
    """Service health check."""
    return {"status": "healthy", "model_loaded": True}</pre>
                </div>

                <h3>6.2 API Design Principles</h3>

                <div class="key-points">
                    <h4>Key Design Principles</h4>
                    <ul>
                        <li><strong>Versioning:</strong> Include API version in URL (e.g., /v1/predict)</li>
                        <li><strong>Idempotency:</strong> Same request should produce same response</li>
                        <li><strong>Error handling:</strong> Return meaningful error messages with codes</li>
                        <li><strong>Rate limiting:</strong> Protect service from overload</li>
                        <li><strong>Authentication:</strong> Secure endpoints with API keys or OAuth</li>
                        <li><strong>Documentation:</strong> Auto-generate OpenAPI/Swagger docs</li>
                    </ul>
                </div>

                <h3>6.3 Handling Errors Gracefully</h3>

                <div class="code-block">
                    <div class="code-label">Python - Error Handling Patterns</div>
                    <pre>
from fastapi import HTTPException
from pydantic import ValidationError

class ModelNotLoadedError(Exception):
    pass

class FeatureValidationError(Exception):
    def __init__(self, feature: str, message: str):
        self.feature = feature
        self.message = message

@app.exception_handler(ModelNotLoadedError)
async def model_error_handler(request, exc):
    return JSONResponse(
        status_code=503,
        content={
            "error": "model_unavailable",
            "message": "Model is not currently available. Please retry.",
            "retry_after": 30
        }
    )

@app.exception_handler(FeatureValidationError)
async def feature_validation_handler(request, exc):
    return JSONResponse(
        status_code=422,
        content={
            "error": "feature_validation_failed",
            "feature": exc.feature,
            "message": exc.message
        }
    )

# Graceful degradation
@app.post("/predict_with_fallback")
async def predict_with_fallback(features: CustomerFeatures):
    try:
        return await predict_single(features)
    except ModelNotLoadedError:
        # Return default/cached prediction
        return PredictionResponse(
            customer_id=features.customer_id,
            churn_probability=0.5,  # Default value
            churn_risk="medium",
            model_version="fallback",
            prediction_id=str(uuid.uuid4())
        )</pre>
                </div>

                <div class="exercise">
                    <h4>Summary: Architecture Design Checklist</h4>
                    <p>When designing your ML system architecture, ensure you have:</p>
                    <ul>
                        <li>Chosen appropriate architecture pattern for team size and scale</li>
                        <li>Implemented feature store for training-serving consistency</li>
                        <li>Set up model registry with proper versioning and staging</li>
                        <li>Designed APIs with proper error handling and documentation</li>
                        <li>Planned for monitoring and observability from the start</li>
                        <li>Considered failure modes and graceful degradation</li>
                    </ul>
                </div>
            </section>

        </div>
    </main>

    <!-- Footer -->
    <footer class="footer">
        <a href="index.html">Course Home</a>
        <a href="framework2_pipeline_engineering.html">Next: Pipeline Engineering</a>
        <a href="../teaching.html">Teaching</a>
        <p style="margin-top: 24px; opacity: 0.7;">© 2025 Chenhao Zhou</p>
    </footer>
</body>
</html>
